; Listing generated by Microsoft (R) Optimizing Compiler Version 19.32.31329.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__83D769C1_concurrencysal@h DB 01H
__D540CC40_sal@h DB 01H
__149FF0EA_vadefs@h DB 01H
__827803DE_vcruntime@h DB 01H
__6569C2CA_corecrt@h DB 01H
__A2143F22_corecrt_stdio_config@h DB 01H
__829E1958_corecrt_wstdio@h DB 01H
__6DFAE8B8_stdio@h DB 01H
__CDDAF8CA_errno@h DB 01H
__2173D5FE_vcruntime_string@h DB 01H
__1FEB9909_corecrt_memcpy_s@h DB 01H
__A751F051_corecrt_memory@h DB 01H
__9200769A_corecrt_wstring@h DB 01H
__32E5F013_string@h DB 01H
__584D2043_stdarg@h DB 01H
__29445515_lprintf@h DB 01H
__6DE7BF50_protocol@h DB 01H
__B30F658D_datalink@h DB 01H
__24DDBC05_datalink@c DB 01H
msvcjmc	ENDS
PUBLIC	main
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BI@GICFHJCA@Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0N@PEINMNIO@Send?5NAK?5?$CFd?6@		; `string'
PUBLIC	??_C@_0N@LKDCMOAL@Send?5ACK?5?$CFd?6@		; `string'
PUBLIC	??_C@_0DC@GEDFCFIM@Designed?5by?5Bonbon?0?5build?3?5May?5@ ; `string'
PUBLIC	??_C@_0CH@HDFIPIGB@?$CK?$CK?$CK?$CK?5Receiver?5Error?0?5Bad?5CRC?5Ch@ ; `string'
PUBLIC	??_C@_0O@DBLMMIFM@Recv?5ACK?5?5?$CFd?6@		; `string'
PUBLIC	??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0O@KMCAAAPA@Recv?5NAK?5?5?$CFd?6@		; `string'
PUBLIC	??_C@_0BG@CGEOBPGK@?9?9?9?9?5DATA?5?$CFd?5timeout?6@ ; `string'
PUBLIC	??_C@_0BF@ELCENNOG@?9?9?9?9?5ACK?5?$CFd?5timeout?6@ ; `string'
EXTRN	memcpy:PROC
EXTRN	lprintf:PROC
EXTRN	protocol_init:PROC
EXTRN	wait_for_event:PROC
EXTRN	enable_network_layer:PROC
EXTRN	disable_network_layer:PROC
EXTRN	get_packet:PROC
EXTRN	put_packet:PROC
EXTRN	recv_frame:PROC
EXTRN	send_frame:PROC
EXTRN	crc32:PROC
EXTRN	start_timer:PROC
EXTRN	stop_timer:PROC
EXTRN	start_ack_timer:PROC
EXTRN	stop_ack_timer:PROC
EXTRN	dbg_event:PROC
EXTRN	dbg_frame:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__CheckForDebuggerJustMyCode:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
nbuffered DB	01H DUP (?)
	ALIGN	4

phl_ready DD	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$between DD imagerel between
	DD	imagerel between+185
	DD	imagerel $unwind$between
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$put_frame DD imagerel put_frame
	DD	imagerel put_frame+113
	DD	imagerel $unwind$put_frame
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$send_the_frame DD imagerel send_the_frame
	DD	imagerel send_the_frame+488
	DD	imagerel $unwind$send_the_frame
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN38
	DD	imagerel $LN38+1431
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BF@ELCENNOG@?9?9?9?9?5ACK?5?$CFd?5timeout?6@
CONST	SEGMENT
??_C@_0BF@ELCENNOG@?9?9?9?9?5ACK?5?$CFd?5timeout?6@ DB '---- ACK %d timeo'
	DB	'ut', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CGEOBPGK@?9?9?9?9?5DATA?5?$CFd?5timeout?6@
CONST	SEGMENT
??_C@_0BG@CGEOBPGK@?9?9?9?9?5DATA?5?$CFd?5timeout?6@ DB '---- DATA %d tim'
	DB	'eout', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KMCAAAPA@Recv?5NAK?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0O@KMCAAAPA@Recv?5NAK?5?5?$CFd?6@ DB 'Recv NAK  %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@
CONST	SEGMENT
??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@ DB 'Recv DATA'
	DB	' %d %d, ID %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DBLMMIFM@Recv?5ACK?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0O@DBLMMIFM@Recv?5ACK?5?5?$CFd?6@ DB 'Recv ACK  %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@HDFIPIGB@?$CK?$CK?$CK?$CK?5Receiver?5Error?0?5Bad?5CRC?5Ch@
CONST	SEGMENT
??_C@_0CH@HDFIPIGB@?$CK?$CK?$CK?$CK?5Receiver?5Error?0?5Bad?5CRC?5Ch@ DB '*'
	DB	'*** Receiver Error, Bad CRC Checksum', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@GEDFCFIM@Designed?5by?5Bonbon?0?5build?3?5May?5@
CONST	SEGMENT
??_C@_0DC@GEDFCFIM@Designed?5by?5Bonbon?0?5build?3?5May?5@ DB 'Designed b'
	DB	'y Bonbon, build: May 21 2022  17:22:36', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LKDCMOAL@Send?5ACK?5?$CFd?6@
CONST	SEGMENT
??_C@_0N@LKDCMOAL@Send?5ACK?5?$CFd?6@ DB 'Send ACK %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PEINMNIO@Send?5NAK?5?$CFd?6@
CONST	SEGMENT
??_C@_0N@PEINMNIO@Send?5NAK?5?$CFd?6@ DB 'Send NAK %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@GICFHJCA@Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@
CONST	SEGMENT
??_C@_0BI@GICFHJCA@Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@ DB 'Send DATA'
	DB	' %d %d, ID %d', 0aH, 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
no_nak	DD	01H
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03fH
	DW	057eH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	025054619H
	DD	0118231dH
	DD	0700b051bH
	DD	0500aH
	DD	imagerel __GSHandlerCheck
	DD	028c8H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
main$rtcName$0 DB 06fH
	DB	06cH
	DB	064H
	DB	065H
	DB	073H
	DB	074H
	DB	05fH
	DB	066H
	DB	072H
	DB	061H
	DB	06dH
	DB	065H
	DB	00H
	ORG $+3
main$rtcName$1 DB 066H
	DB	00H
	ORG $+6
main$rtcName$2 DB 06fH
	DB	075H
	DB	074H
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+5
main$rtcName$3 DB 069H
	DB	06eH
	DB	05fH
	DB	062H
	DB	075H
	DB	066H
	DB	066H
	DB	065H
	DB	072H
	DB	00H
	ORG $+6
main$rtcName$4 DB 061H
	DB	072H
	DB	072H
	DB	069H
	DB	076H
	DB	065H
	DB	064H
	DB	00H
main$rtcVarDesc DD 02280H
	DD	040H
	DQ	FLAT:main$rtcName$4
	DD	011e0H
	DD	01000H
	DQ	FLAT:main$rtcName$3
	DD	01c0H
	DD	01000H
	DQ	FLAT:main$rtcName$2
	DD	070H
	DD	0108H
	DQ	FLAT:main$rtcName$1
	DD	044H
	DD	04H
	DQ	FLAT:main$rtcName$0
	ORG $+240
main$rtcFrameData DD 05H
	DD	00H
	DQ	FLAT:main$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	043H
	DW	01cfH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$send_the_frame DD 025054a19H
	DD	011b2320H
	DD	070140043H
	DD	05013H
	DD	imagerel __GSHandlerCheck
	DD	0208H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
send_the_frame$rtcName$0 DB 073H
	DB	00H
	ORG $+14
send_the_frame$rtcVarDesc DD 030H
	DD	0108H
	DQ	FLAT:send_the_frame$rtcName$0
	ORG $+48
send_the_frame$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:send_the_frame$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$put_frame DD 025051701H
	DD	01122317H
	DD	0700b001dH
	DD	0500aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$between DD 025051b01H
	DD	0116231bH
	DD	0700f001fH
	DD	0500eH
xdata	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
	ret	0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File E:\学习\计网\Lab1-2022(Win+Linux)\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\datalink.c
;	COMDAT main
_TEXT	SEGMENT
event$ = 4
oldest_frame$ = 36
f$ = 80
len$ = 372
out_buffer$ = 416
in_buffer$ = 4544
ack_expected$ = 8660
next_frame_to_send$ = 8692
frame_expected$ = 8724
too_far$ = 8756
arrived$ = 8800
tv74 = 10404
__$ArrayPad$ = 10408
argc$ = 10448
argv$ = 10456
main	PROC						; COMDAT

; 70   : {

$LN38:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	push	rbp
	push	rdi
	mov	eax, 10456				; 000028d8H
	call	__chkstk
	sub	rsp, rax
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 2222				; 000008aeH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, DWORD PTR [rsp+10488]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__24DDBC05_datalink@c
	call	__CheckForDebuggerJustMyCode

; 71   :     int event, oldest_frame;
; 72   :     struct FRAME f;
; 73   :     int len = 0;

	mov	DWORD PTR len$[rbp], 0

; 74   :     struct packet out_buffer[NR_BUFS];
; 75   :     struct packet in_buffer[NR_BUFS];
; 76   :     unsigned char ack_expected = 0;

	mov	BYTE PTR ack_expected$[rbp], 0

; 77   :     unsigned char next_frame_to_send = 0;

	mov	BYTE PTR next_frame_to_send$[rbp], 0

; 78   :     unsigned char frame_expected = 0;

	mov	BYTE PTR frame_expected$[rbp], 0

; 79   :     unsigned char too_far = NR_BUFS;

	mov	BYTE PTR too_far$[rbp], 16

; 80   :     int arrived[NR_BUFS] = { 0 };

	lea	rax, QWORD PTR arrived$[rbp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 64					; 00000040H
	rep stosb

; 81   : 
; 82   :     protocol_init(argc, argv);

	mov	rdx, QWORD PTR argv$[rbp]
	mov	ecx, DWORD PTR argc$[rbp]
	call	protocol_init

; 83   :     lprintf("Designed by Bonbon, build: " __DATE__ "  "__TIME__"\n");

	lea	rcx, OFFSET FLAT:??_C@_0DC@GEDFCFIM@Designed?5by?5Bonbon?0?5build?3?5May?5@
	call	lprintf

; 84   : 
; 85   :     disable_network_layer();

	call	disable_network_layer
$LN2@main:

; 86   : 
; 87   :     while (1) {

	xor	eax, eax
	cmp	eax, 1
	je	$LN3@main

; 88   :         event = wait_for_event(&oldest_frame);

	lea	rcx, QWORD PTR oldest_frame$[rbp]
	call	wait_for_event
	mov	DWORD PTR event$[rbp], eax

; 89   : 
; 90   :         switch (event) {

	mov	eax, DWORD PTR event$[rbp]
	mov	DWORD PTR tv74[rbp], eax
	cmp	DWORD PTR tv74[rbp], 0
	je	SHORT $LN10@main
	cmp	DWORD PTR tv74[rbp], 1
	je	$LN13@main
	cmp	DWORD PTR tv74[rbp], 2
	je	$LN14@main
	cmp	DWORD PTR tv74[rbp], 3
	je	$LN32@main
	cmp	DWORD PTR tv74[rbp], 4
	je	$LN34@main
	jmp	$LN4@main
$LN10@main:

; 91   :             case NETWORK_LAYER_READY:
; 92   :                 get_packet(out_buffer[next_frame_to_send % NR_BUFS].data);

	movzx	eax, BYTE PTR next_frame_to_send$[rbp]
	cdq
	and	edx, 15
	add	eax, edx
	and	eax, 15
	sub	eax, edx
	cdqe
	imul	rax, rax, 256				; 00000100H
	lea	rax, QWORD PTR out_buffer$[rbp+rax]
	mov	rcx, rax
	call	get_packet

; 93   :                 nbuffered++;

	movzx	eax, BYTE PTR nbuffered
	inc	al
	mov	BYTE PTR nbuffered, al

; 94   :                 send_the_frame(FRAME_DATA, next_frame_to_send, frame_expected, out_buffer);

	lea	r9, QWORD PTR out_buffer$[rbp]
	movzx	r8d, BYTE PTR frame_expected$[rbp]
	movzx	edx, BYTE PTR next_frame_to_send$[rbp]
	mov	cl, 1
	call	send_the_frame

; 95   :                 inc(next_frame_to_send);

	movzx	eax, BYTE PTR next_frame_to_send$[rbp]
	cmp	eax, 31
	jge	SHORT $LN11@main
	movzx	eax, BYTE PTR next_frame_to_send$[rbp]
	inc	al
	mov	BYTE PTR next_frame_to_send$[rbp], al
	jmp	SHORT $LN12@main
$LN11@main:
	mov	BYTE PTR next_frame_to_send$[rbp], 0
$LN12@main:

; 96   :                 break;

	jmp	$LN4@main
$LN13@main:

; 97   : 
; 98   :             case PHYSICAL_LAYER_READY:
; 99   :                 phl_ready = 1;

	mov	DWORD PTR phl_ready, 1

; 100  :                 break;

	jmp	$LN4@main
$LN14@main:

; 101  : 
; 102  :             case FRAME_RECEIVED:
; 103  :                 len = recv_frame((unsigned char*)&f, sizeof f);

	mov	edx, 264				; 00000108H
	lea	rcx, QWORD PTR f$[rbp]
	call	recv_frame
	mov	DWORD PTR len$[rbp], eax

; 104  : 
; 105  :                 if ((len < 7 && len != 2) || (len >= 7 && crc32((unsigned char*)&f, len) != 0)) {

	cmp	DWORD PTR len$[rbp], 7
	jge	SHORT $LN17@main
	cmp	DWORD PTR len$[rbp], 2
	jne	SHORT $LN16@main
$LN17@main:
	cmp	DWORD PTR len$[rbp], 7
	jl	SHORT $LN15@main
	mov	edx, DWORD PTR len$[rbp]
	lea	rcx, QWORD PTR f$[rbp]
	call	crc32
	test	eax, eax
	je	SHORT $LN15@main
$LN16@main:

; 106  :                     dbg_event("**** Receiver Error, Bad CRC Checksum\n");

	lea	rcx, OFFSET FLAT:??_C@_0CH@HDFIPIGB@?$CK?$CK?$CK?$CK?5Receiver?5Error?0?5Bad?5CRC?5Ch@
	call	dbg_event

; 107  :                     if (no_nak == 1) {

	cmp	DWORD PTR no_nak, 1
	jne	SHORT $LN18@main

; 108  :                         send_the_frame(FRAME_NAK, 0, frame_expected, out_buffer);

	lea	r9, QWORD PTR out_buffer$[rbp]
	movzx	r8d, BYTE PTR frame_expected$[rbp]
	xor	edx, edx
	mov	cl, 3
	call	send_the_frame
$LN18@main:

; 109  :                     }
; 110  :                     break;

	jmp	$LN4@main
$LN15@main:

; 111  :                 }
; 112  : 
; 113  :                 if (f.kind == FRAME_ACK)

	movzx	eax, BYTE PTR f$[rbp]
	cmp	eax, 2
	jne	SHORT $LN19@main

; 114  :                     dbg_frame("Recv ACK  %d\n", f.ack);

	movzx	eax, BYTE PTR f$[rbp+1]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0O@DBLMMIFM@Recv?5ACK?5?5?$CFd?6@
	call	dbg_frame
$LN19@main:

; 115  : 
; 116  :                 if (f.kind == FRAME_DATA) {

	movzx	eax, BYTE PTR f$[rbp]
	cmp	eax, 1
	jne	$LN20@main

; 117  :                     dbg_frame("Recv DATA %d %d, ID %d\n", f.seq, f.ack, *(short*)f.data);

	movsx	eax, WORD PTR f$[rbp+3]
	movzx	ecx, BYTE PTR f$[rbp+1]
	movzx	edx, BYTE PTR f$[rbp+2]
	mov	r9d, eax
	mov	r8d, ecx
	lea	rcx, OFFSET FLAT:??_C@_0BI@LEOKNOFG@Recv?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@
	call	dbg_frame

; 118  :                     if (f.seq != frame_expected && no_nak == 1) {

	movzx	eax, BYTE PTR f$[rbp+2]
	movzx	ecx, BYTE PTR frame_expected$[rbp]
	cmp	eax, ecx
	je	SHORT $LN21@main
	cmp	DWORD PTR no_nak, 1
	jne	SHORT $LN21@main

; 119  :                         send_the_frame(FRAME_NAK, 0, frame_expected, out_buffer);

	lea	r9, QWORD PTR out_buffer$[rbp]
	movzx	r8d, BYTE PTR frame_expected$[rbp]
	xor	edx, edx
	mov	cl, 3
	call	send_the_frame

; 120  :                     }

	jmp	SHORT $LN22@main
$LN21@main:

; 121  :                     else {
; 122  :                         start_ack_timer(ACK_TIMER);

	mov	ecx, 280				; 00000118H
	call	start_ack_timer
$LN22@main:

; 123  :                     }
; 124  :                     if (between(frame_expected, f.seq, too_far) && arrived[f.seq % NR_BUFS] == 0) {

	movzx	r8d, BYTE PTR too_far$[rbp]
	movzx	edx, BYTE PTR f$[rbp+2]
	movzx	ecx, BYTE PTR frame_expected$[rbp]
	call	between
	test	eax, eax
	je	$LN23@main
	movzx	eax, BYTE PTR f$[rbp+2]
	cdq
	and	edx, 15
	add	eax, edx
	and	eax, 15
	sub	eax, edx
	cdqe
	cmp	DWORD PTR arrived$[rbp+rax*4], 0
	jne	$LN23@main

; 125  :                         arrived[f.seq % NR_BUFS] = 1;

	movzx	eax, BYTE PTR f$[rbp+2]
	cdq
	and	edx, 15
	add	eax, edx
	and	eax, 15
	sub	eax, edx
	cdqe
	mov	DWORD PTR arrived$[rbp+rax*4], 1

; 126  :                         memcpy(in_buffer[f.seq % NR_BUFS].data, f.data, PKT_LEN);

	movzx	eax, BYTE PTR f$[rbp+2]
	cdq
	and	edx, 15
	add	eax, edx
	and	eax, 15
	sub	eax, edx
	cdqe
	imul	rax, rax, 256				; 00000100H
	lea	rax, QWORD PTR in_buffer$[rbp+rax]
	mov	r8d, 256				; 00000100H
	lea	rdx, QWORD PTR f$[rbp+3]
	mov	rcx, rax
	call	memcpy
$LN6@main:

; 127  :                         while (arrived[frame_expected % NR_BUFS]) {

	movzx	eax, BYTE PTR frame_expected$[rbp]
	cdq
	and	edx, 15
	add	eax, edx
	and	eax, 15
	sub	eax, edx
	cdqe
	cmp	DWORD PTR arrived$[rbp+rax*4], 0
	je	$LN7@main

; 128  :                             put_packet(in_buffer[frame_expected % NR_BUFS].data, PKT_LEN);

	movzx	eax, BYTE PTR frame_expected$[rbp]
	cdq
	and	edx, 15
	add	eax, edx
	and	eax, 15
	sub	eax, edx
	cdqe
	imul	rax, rax, 256				; 00000100H
	lea	rax, QWORD PTR in_buffer$[rbp+rax]
	mov	edx, 256				; 00000100H
	mov	rcx, rax
	call	put_packet

; 129  :                             arrived[frame_expected % NR_BUFS] = 0;

	movzx	eax, BYTE PTR frame_expected$[rbp]
	cdq
	and	edx, 15
	add	eax, edx
	and	eax, 15
	sub	eax, edx
	cdqe
	mov	DWORD PTR arrived$[rbp+rax*4], 0

; 130  :                             inc(frame_expected);

	movzx	eax, BYTE PTR frame_expected$[rbp]
	cmp	eax, 31
	jge	SHORT $LN24@main
	movzx	eax, BYTE PTR frame_expected$[rbp]
	inc	al
	mov	BYTE PTR frame_expected$[rbp], al
	jmp	SHORT $LN25@main
$LN24@main:
	mov	BYTE PTR frame_expected$[rbp], 0
$LN25@main:

; 131  :                             inc(too_far);

	movzx	eax, BYTE PTR too_far$[rbp]
	cmp	eax, 31
	jge	SHORT $LN26@main
	movzx	eax, BYTE PTR too_far$[rbp]
	inc	al
	mov	BYTE PTR too_far$[rbp], al
	jmp	SHORT $LN27@main
$LN26@main:
	mov	BYTE PTR too_far$[rbp], 0
$LN27@main:

; 132  :                             no_nak = 1;

	mov	DWORD PTR no_nak, 1

; 133  :                             start_ack_timer(ACK_TIMER);

	mov	ecx, 280				; 00000118H
	call	start_ack_timer

; 134  :                         }

	jmp	$LN6@main
$LN7@main:
$LN23@main:
$LN20@main:

; 135  :                     }
; 136  :                 }
; 137  : 
; 138  :                 if (f.kind == FRAME_NAK) {

	movzx	eax, BYTE PTR f$[rbp]
	cmp	eax, 3
	jne	SHORT $LN28@main

; 139  :                     dbg_frame("Recv NAK  %d\n", f.ack);

	movzx	eax, BYTE PTR f$[rbp+1]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0O@KMCAAAPA@Recv?5NAK?5?5?$CFd?6@
	call	dbg_frame

; 140  :                     if (between(ack_expected, (f.ack + 1) % (MAX_SEQ + 1), next_frame_to_send)) {

	movzx	eax, BYTE PTR f$[rbp+1]
	inc	eax
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	movzx	r8d, BYTE PTR next_frame_to_send$[rbp]
	movzx	edx, al
	movzx	ecx, BYTE PTR ack_expected$[rbp]
	call	between
	test	eax, eax
	je	SHORT $LN29@main

; 141  :                         send_the_frame(FRAME_DATA, (f.ack + 1) % (MAX_SEQ + 1), frame_expected, out_buffer);

	movzx	eax, BYTE PTR f$[rbp+1]
	inc	eax
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	lea	r9, QWORD PTR out_buffer$[rbp]
	movzx	r8d, BYTE PTR frame_expected$[rbp]
	movzx	edx, al
	mov	cl, 1
	call	send_the_frame
$LN29@main:
$LN28@main:
$LN8@main:

; 142  :                     }
; 143  :                 }
; 144  : 
; 145  :                 while (between(ack_expected, f.ack, next_frame_to_send)) {

	movzx	r8d, BYTE PTR next_frame_to_send$[rbp]
	movzx	edx, BYTE PTR f$[rbp+1]
	movzx	ecx, BYTE PTR ack_expected$[rbp]
	call	between
	test	eax, eax
	je	SHORT $LN9@main

; 146  :                     stop_timer(ack_expected % NR_BUFS);

	movzx	eax, BYTE PTR ack_expected$[rbp]
	cdq
	and	edx, 15
	add	eax, edx
	and	eax, 15
	sub	eax, edx
	mov	ecx, eax
	call	stop_timer

; 147  :                     inc(ack_expected);

	movzx	eax, BYTE PTR ack_expected$[rbp]
	cmp	eax, 31
	jge	SHORT $LN30@main
	movzx	eax, BYTE PTR ack_expected$[rbp]
	inc	al
	mov	BYTE PTR ack_expected$[rbp], al
	jmp	SHORT $LN31@main
$LN30@main:
	mov	BYTE PTR ack_expected$[rbp], 0
$LN31@main:

; 148  :                     nbuffered--;

	movzx	eax, BYTE PTR nbuffered
	dec	al
	mov	BYTE PTR nbuffered, al

; 149  :                 }

	jmp	SHORT $LN8@main
$LN9@main:

; 150  : 
; 151  :                 break;

	jmp	SHORT $LN4@main
$LN32@main:

; 152  : 
; 153  :             case DATA_TIMEOUT:
; 154  :                 dbg_event("---- DATA %d timeout\n", oldest_frame);

	mov	edx, DWORD PTR oldest_frame$[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0BG@CGEOBPGK@?9?9?9?9?5DATA?5?$CFd?5timeout?6@
	call	dbg_event

; 155  :                 if (!between(ack_expected, oldest_frame, next_frame_to_send)) {

	movzx	r8d, BYTE PTR next_frame_to_send$[rbp]
	movzx	edx, BYTE PTR oldest_frame$[rbp]
	movzx	ecx, BYTE PTR ack_expected$[rbp]
	call	between
	test	eax, eax
	jne	SHORT $LN33@main

; 156  :                     oldest_frame += NR_BUFS;

	mov	eax, DWORD PTR oldest_frame$[rbp]
	add	eax, 16
	mov	DWORD PTR oldest_frame$[rbp], eax
$LN33@main:

; 157  :                 }
; 158  :                 send_the_frame(FRAME_DATA, oldest_frame, frame_expected, out_buffer);

	lea	r9, QWORD PTR out_buffer$[rbp]
	movzx	r8d, BYTE PTR frame_expected$[rbp]
	movzx	edx, BYTE PTR oldest_frame$[rbp]
	mov	cl, 1
	call	send_the_frame

; 159  :                 break;

	jmp	SHORT $LN4@main
$LN34@main:

; 160  : 
; 161  :             case ACK_TIMEOUT:
; 162  :                 dbg_event("---- ACK %d timeout\n", oldest_frame);

	mov	edx, DWORD PTR oldest_frame$[rbp]
	lea	rcx, OFFSET FLAT:??_C@_0BF@ELCENNOG@?9?9?9?9?5ACK?5?$CFd?5timeout?6@
	call	dbg_event

; 163  :                 send_the_frame(FRAME_ACK, 0, frame_expected, out_buffer);

	lea	r9, QWORD PTR out_buffer$[rbp]
	movzx	r8d, BYTE PTR frame_expected$[rbp]
	xor	edx, edx
	mov	cl, 2
	call	send_the_frame
$LN4@main:

; 164  :                 break;
; 165  :         }
; 166  : 
; 167  : 
; 168  :         if (nbuffered < NR_BUFS && phl_ready == 1)

	movzx	eax, BYTE PTR nbuffered
	cmp	eax, 16
	jge	SHORT $LN35@main
	cmp	DWORD PTR phl_ready, 1
	jne	SHORT $LN35@main

; 169  :             enable_network_layer();

	call	enable_network_layer
	jmp	SHORT $LN36@main
$LN35@main:

; 170  :         else
; 171  :             disable_network_layer();

	call	disable_network_layer
$LN36@main:

; 172  :     }

	jmp	$LN2@main
$LN3@main:

; 173  : }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:main$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+10424]
	pop	rdi
	pop	rbp
	ret	0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File E:\学习\计网\Lab1-2022(Win+Linux)\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\datalink.c
;	COMDAT send_the_frame
_TEXT	SEGMENT
s$ = 16
tv66 = 484
__$ArrayPad$ = 488
kind$ = 528
frame_nr$ = 536
frame_expceted$ = 544
buffer$ = 552
send_the_frame PROC					; COMDAT

; 41   : {

	mov	QWORD PTR [rsp+32], r9
	mov	BYTE PTR [rsp+24], r8b
	mov	BYTE PTR [rsp+16], dl
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 536				; 00000218H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rdi, QWORD PTR [rsp+32]
	mov	ecx, 78					; 0000004eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	movzx	ecx, BYTE PTR [rsp+568]
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rbp
	mov	QWORD PTR __$ArrayPad$[rbp], rax
	lea	rcx, OFFSET FLAT:__24DDBC05_datalink@c
	call	__CheckForDebuggerJustMyCode

; 42   :     struct FRAME s;
; 43   :     s.kind = kind;

	movzx	eax, BYTE PTR kind$[rbp]
	mov	BYTE PTR s$[rbp], al

; 44   :     if (kind == FRAME_DATA) {

	movzx	eax, BYTE PTR kind$[rbp]
	cmp	eax, 1
	jne	$LN2@send_the_f

; 45   :         memcpy(s.data, buffer[frame_nr % NR_BUFS].data, PKT_LEN);

	movzx	eax, BYTE PTR frame_nr$[rbp]
	cdq
	and	edx, 15
	add	eax, edx
	and	eax, 15
	sub	eax, edx
	cdqe
	imul	rax, rax, 256				; 00000100H
	mov	rcx, QWORD PTR buffer$[rbp]
	add	rcx, rax
	mov	rax, rcx
	mov	r8d, 256				; 00000100H
	mov	rdx, rax
	lea	rcx, QWORD PTR s$[rbp+3]
	call	memcpy

; 46   :         s.seq = frame_nr;

	movzx	eax, BYTE PTR frame_nr$[rbp]
	mov	BYTE PTR s$[rbp+2], al

; 47   :         dbg_frame("Send DATA %d %d, ID %d\n", frame_nr, ((frame_expceted + MAX_SEQ) % (MAX_SEQ + 1)), *(short*)s.data);

	movsx	eax, WORD PTR s$[rbp+3]
	mov	DWORD PTR tv66[rbp], eax
	movzx	ecx, BYTE PTR frame_expceted$[rbp]
	add	ecx, 31
	mov	eax, ecx
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	movzx	ecx, BYTE PTR frame_nr$[rbp]
	mov	edx, DWORD PTR tv66[rbp]
	mov	r9d, edx
	mov	r8d, eax
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:??_C@_0BI@GICFHJCA@Send?5DATA?5?$CFd?5?$CFd?0?5ID?5?$CFd?6@
	call	dbg_frame
$LN2@send_the_f:

; 48   :     }
; 49   :     s.ack = ((frame_expceted + MAX_SEQ) % (MAX_SEQ + 1));

	movzx	eax, BYTE PTR frame_expceted$[rbp]
	add	eax, 31
	cdq
	and	edx, 31
	add	eax, edx
	and	eax, 31
	sub	eax, edx
	mov	BYTE PTR s$[rbp+1], al

; 50   :     if (kind == FRAME_NAK) {

	movzx	eax, BYTE PTR kind$[rbp]
	cmp	eax, 3
	jne	SHORT $LN3@send_the_f

; 51   :         dbg_frame("Send NAK %d\n", frame_expceted);

	movzx	eax, BYTE PTR frame_expceted$[rbp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0N@PEINMNIO@Send?5NAK?5?$CFd?6@
	call	dbg_frame

; 52   :         no_nak = 0;

	mov	DWORD PTR no_nak, 0
$LN3@send_the_f:

; 53   :     }
; 54   :     if (kind == FRAME_ACK) {

	movzx	eax, BYTE PTR kind$[rbp]
	cmp	eax, 2
	jne	SHORT $LN4@send_the_f

; 55   :         dbg_frame("Send ACK %d\n", frame_expceted);

	movzx	eax, BYTE PTR frame_expceted$[rbp]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:??_C@_0N@LKDCMOAL@Send?5ACK?5?$CFd?6@
	call	dbg_frame
$LN4@send_the_f:

; 56   :     }
; 57   :     if (kind == FRAME_ACK || kind == FRAME_NAK) {

	movzx	eax, BYTE PTR kind$[rbp]
	cmp	eax, 2
	je	SHORT $LN7@send_the_f
	movzx	eax, BYTE PTR kind$[rbp]
	cmp	eax, 3
	jne	SHORT $LN5@send_the_f
$LN7@send_the_f:

; 58   :         send_frame((unsigned char*)&s, 2);

	mov	edx, 2
	lea	rcx, QWORD PTR s$[rbp]
	call	send_frame

; 59   :     }

	jmp	SHORT $LN6@send_the_f
$LN5@send_the_f:

; 60   :     else {
; 61   :         put_frame((unsigned char*)&s, 3 + PKT_LEN);

	mov	edx, 259				; 00000103H
	lea	rcx, QWORD PTR s$[rbp]
	call	put_frame
$LN6@send_the_f:

; 62   :     }
; 63   :     if (kind == FRAME_DATA) {

	movzx	eax, BYTE PTR kind$[rbp]
	cmp	eax, 1
	jne	SHORT $LN8@send_the_f

; 64   :         start_timer(frame_nr % NR_BUFS, DATA_TIMER);

	movzx	eax, BYTE PTR frame_nr$[rbp]
	cdq
	and	edx, 15
	add	eax, edx
	and	eax, 15
	sub	eax, edx
	mov	edx, 2000				; 000007d0H
	mov	ecx, eax
	call	start_timer
$LN8@send_the_f:

; 65   :     }
; 66   :     stop_ack_timer();

	call	stop_ack_timer

; 67   : }

	lea	rcx, QWORD PTR [rbp-32]
	lea	rdx, OFFSET FLAT:send_the_frame$rtcFrameData
	call	_RTC_CheckStackVars
	mov	rcx, QWORD PTR __$ArrayPad$[rbp]
	xor	rcx, rbp
	call	__security_check_cookie
	lea	rsp, QWORD PTR [rbp+504]
	pop	rdi
	pop	rbp
	ret	0
send_the_frame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File E:\学习\计网\Lab1-2022(Win+Linux)\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\datalink.c
;	COMDAT put_frame
_TEXT	SEGMENT
frame$ = 224
len$ = 232
put_frame PROC						; COMDAT

; 34   : static void put_frame(unsigned char* frame, int len) {

	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbp
	push	rdi
	sub	rsp, 232				; 000000e8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__24DDBC05_datalink@c
	call	__CheckForDebuggerJustMyCode

; 35   :     *(unsigned int*)(frame + len) = crc32(frame, len);

	mov	edx, DWORD PTR len$[rbp]
	mov	rcx, QWORD PTR frame$[rbp]
	call	crc32
	movsxd	rcx, DWORD PTR len$[rbp]
	mov	rdx, QWORD PTR frame$[rbp]
	mov	DWORD PTR [rdx+rcx], eax

; 36   :     send_frame(frame, len + 4);

	mov	eax, DWORD PTR len$[rbp]
	add	eax, 4
	mov	edx, eax
	mov	rcx, QWORD PTR frame$[rbp]
	call	send_frame

; 37   :     phl_ready = 0;

	mov	DWORD PTR phl_ready, 0

; 38   : }

	lea	rsp, QWORD PTR [rbp+200]
	pop	rdi
	pop	rbp
	ret	0
put_frame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File E:\学习\计网\Lab1-2022(Win+Linux)\Lab1-2022(Win+Linux)\Lab1-Windows-VS2019\datalink.c
;	COMDAT between
_TEXT	SEGMENT
tv82 = 192
a$ = 240
b$ = 248
c$ = 256
between	PROC						; COMDAT

; 30   : static int between(unsigned char a, unsigned char b, unsigned char c) {

	mov	BYTE PTR [rsp+24], r8b
	mov	BYTE PTR [rsp+16], dl
	mov	BYTE PTR [rsp+8], cl
	push	rbp
	push	rdi
	sub	rsp, 248				; 000000f8H
	lea	rbp, QWORD PTR [rsp+32]
	lea	rcx, OFFSET FLAT:__24DDBC05_datalink@c
	call	__CheckForDebuggerJustMyCode

; 31   :     return ((a <= b) && (b < c)) || ((c < a) && (a <= b)) || ((b < c) && (c < a));

	movzx	eax, BYTE PTR a$[rbp]
	movzx	ecx, BYTE PTR b$[rbp]
	cmp	eax, ecx
	jg	SHORT $LN3@between
	movzx	eax, BYTE PTR b$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	cmp	eax, ecx
	jl	SHORT $LN5@between
$LN3@between:
	movzx	eax, BYTE PTR c$[rbp]
	movzx	ecx, BYTE PTR a$[rbp]
	cmp	eax, ecx
	jge	SHORT $LN4@between
	movzx	eax, BYTE PTR a$[rbp]
	movzx	ecx, BYTE PTR b$[rbp]
	cmp	eax, ecx
	jle	SHORT $LN5@between
$LN4@between:
	movzx	eax, BYTE PTR b$[rbp]
	movzx	ecx, BYTE PTR c$[rbp]
	cmp	eax, ecx
	jge	SHORT $LN6@between
	movzx	eax, BYTE PTR c$[rbp]
	movzx	ecx, BYTE PTR a$[rbp]
	cmp	eax, ecx
	jl	SHORT $LN5@between
$LN6@between:
	mov	DWORD PTR tv82[rbp], 0
	jmp	SHORT $LN7@between
$LN5@between:
	mov	DWORD PTR tv82[rbp], 1
$LN7@between:
	mov	eax, DWORD PTR tv82[rbp]

; 32   : }

	lea	rsp, QWORD PTR [rbp+216]
	pop	rdi
	pop	rbp
	ret	0
between	ENDP
_TEXT	ENDS
END
